<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我答应了十八岁的自己不会变"><title>Kubernetes初识 | SilverBullet</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kubernetes初识</h1><a id="logo" href="/.">SilverBullet</a><p class="description">说些自己想说的话</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/tag/"><i class="fa fa-tags"> tag</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kubernetes初识</h1><div class="post-meta">2019-07-11<span> | </span><span class="category"><a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">设计架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">Kubernetes节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubelet"><span class="toc-number">1.2.</span> <span class="toc-text">kubelet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kube-proxy"><span class="toc-number">1.3.</span> <span class="toc-text">kube-proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF"><span class="toc-number">1.4.</span> <span class="toc-text">Kubernetes控制面板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etcd"><span class="toc-number">1.5.</span> <span class="toc-text">etcd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes-API-Server"><span class="toc-number">1.6.</span> <span class="toc-text">Kubernetes API Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduler"><span class="toc-number">1.7.</span> <span class="toc-text">Scheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">Kubernetes控制管理服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kubernetes%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">kubernetes设计理念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5%E5%92%8CAPI%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">Kubernetes的核心技术概念和API对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pod"><span class="toc-number">2.1.1.</span> <span class="toc-text">Pod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88Replication-Controller%EF%BC%8CRC%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">复制控制器（Replication Controller，RC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E9%9B%86%EF%BC%88Replica-Set%EF%BC%8CRS%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">副本集（Replica Set，RS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-Deployment"><span class="toc-number">2.1.4.</span> <span class="toc-text">部署(Deployment)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%EF%BC%88Service%EF%BC%89"><span class="toc-number">2.1.5.</span> <span class="toc-text">服务（Service）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%EF%BC%88Job%EF%BC%89"><span class="toc-number">2.1.6.</span> <span class="toc-text">任务（Job）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E6%94%AF%E6%92%91%E6%9C%8D%E5%8A%A1%E9%9B%86%EF%BC%88DaemonSet%EF%BC%89"><span class="toc-number">2.1.7.</span> <span class="toc-text">后台支撑服务集（DaemonSet）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E9%9B%86%EF%BC%88PetSet%EF%BC%89"><span class="toc-number">2.1.8.</span> <span class="toc-text">有状态服务集（PetSet）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%EF%BC%88Federation%EF%BC%89"><span class="toc-number">2.1.9.</span> <span class="toc-text">集群联邦（Federation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8D%B7%EF%BC%88Volume%EF%BC%89"><span class="toc-number">2.1.10.</span> <span class="toc-text">存储卷（Volume）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8%E5%8D%B7%EF%BC%88Persistent-Volume%EF%BC%8CPV%EF%BC%89%E5%92%8C%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8%E5%8D%B7%E5%A3%B0%E6%98%8E%EF%BC%88Persistent-Volume-Claim%EF%BC%8CPVC%EF%BC%89"><span class="toc-number">2.1.11.</span> <span class="toc-text">持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89"><span class="toc-number">2.1.12.</span> <span class="toc-text">节点（Node）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%AF%B9%E8%B1%A1%EF%BC%88Secret%EF%BC%89"><span class="toc-number">2.1.13.</span> <span class="toc-text">密钥对象（Secret）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7%EF%BC%88User-Account%EF%BC%89%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%B8%90%E6%88%B7%EF%BC%88Service-Account%EF%BC%89"><span class="toc-number">2.1.14.</span> <span class="toc-text">用户帐户（User Account）和服务帐户（Service Account）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4%EF%BC%88Namespace%EF%BC%89"><span class="toc-number">2.1.15.</span> <span class="toc-text">名字空间（Namespace）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RBAC%E8%AE%BF%E9%97%AE%E6%8E%88%E6%9D%83"><span class="toc-number">2.1.16.</span> <span class="toc-text">RBAC访问授权</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="post-content"><p><a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/"><strong>Kubernetes</strong></a>是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p>
<p>Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着（比如用户想让apache一直运行，用户不需要关心怎么去做，Kubernetes会自动去监控，然后去重启，新建，总之，让apache一直提供服务），管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用（就像canary deployments）。</p>
<span id="more"></span>



<h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><p>Kubernetes集群包含有节点代理kubelet和Master组件(APIs, scheduler, etc)，一切都基于分布式的存储系统。下面这张图是Kubernetes的架构图。</p>
<p><img src="/2019/07/11/Kubernetes_DOC/Structure.jpg" alt="架构"></p>
<h3 id="Kubernetes节点"><a href="#Kubernetes节点" class="headerlink" title="Kubernetes节点"></a>Kubernetes节点</h3><p>Kubernetes节点有运行应用容器必备的服务，而这些都是受Master的控制。</p>
<p>每次个节点上当然都要运行Docker。Docker来负责所有具体的映像下载和容器运行。</p>
<p>Kubernetes主要由以下几个核心组件组成：</p>
<ul>
<li><strong>etcd</strong>保存了整个集群的状态；</li>
<li><strong>apiserver</strong>提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>
<li><strong>controller manager</strong>负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li><strong>schedule</strong>r负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>
<li>kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</li>
<li><strong>Container runtime</strong>负责镜像管理以及Pod和容器的真正运行（CRI）；</li>
<li><strong>kube-proxy</strong>负责为Service提供cluster内部的服务发现和负载均衡；</li>
</ul>
<p>除了核心组件，还有一些推荐的Add-ons：</p>
<ul>
<li><strong>kube-dns</strong>负责为整个集群提供DNS服务</li>
<li><strong>Ingress Controller</strong>为服务提供外网入口</li>
<li><strong>Heapster</strong>提供资源监控</li>
<li><strong>Dashboard</strong>提供GUI</li>
<li><strong>Federation</strong>提供跨可用区的集群</li>
<li><strong>Fluentd-elasticsearch</strong> 提供集群日志采集、存储与查询</li>
</ul>
<p><img src="/2019/07/11/Kubernetes_DOC/KubernetesMaster.png" alt="KuberMaster"></p>
<p><img src="/2019/07/11/Kubernetes_DOC/KubernetesNode.png" alt="KuberNetesNode"></p>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>kubelet负责管理<a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/kubernetes-pod">pods</a>和它们上面的容器，images镜像、volumes、etc。</p>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>每一个节点也运行一个简单的网络代理和负载均衡（详见<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/wiki/Services-FAQ">services FAQ</a> )（PS:官方 英文）。 正如Kubernetes API里面定义的这些服务（详见<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/user-guide/services.md">the services doc</a>）（PS:官方 英文）也可以在各种终端中以轮询的方式做一些简单的TCP和UDP传输。</p>
<p>服务端点目前是通过DNS或者环境变量( <code>Docker-links-compatible</code> 和 <code>Kubernetes&#123;FOO&#125;_SERVICE_HOST </code>及 <code>&#123;FOO&#125;_SERVICE_PORT </code>变量都支持)。这些变量由服务代理所管理的端口来解析。</p>
<h3 id="Kubernetes控制面板"><a href="#Kubernetes控制面板" class="headerlink" title="Kubernetes控制面板"></a>Kubernetes控制面板</h3><p>Kubernetes控制面板可以分为多个部分。目前它们都运行在一个<em>master</em> 节点，然而为了达到高可用性，这需要改变。不同部分一起协作提供一个统一的关于集群的视图。</p>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>所有master的持续状态都存在etcd的一个实例中。这可以很好地存储配置数据。因为有watch(观察者)的支持，各部件协调中的改变可以很快被察觉。</p>
<h3 id="Kubernetes-API-Server"><a href="#Kubernetes-API-Server" class="headerlink" title="Kubernetes API Server"></a>Kubernetes API Server</h3><p>API服务提供<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/api.md">Kubernetes API</a> （PS:官方 英文）的服务。这个服务试图通过把所有或者大部分的业务逻辑放到不两只的部件中从而使其具有CRUD特性。它主要处理REST操作，在etcd中验证更新这些对象（并最终存储）。</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>调度器把未调度的pod通过binding api绑定到节点上。调度器是可插拔的，并且我们期待支持多集群的调度，未来甚至希望可以支持用户自定义的调度器。</p>
<h3 id="Kubernetes控制管理服务器"><a href="#Kubernetes控制管理服务器" class="headerlink" title="Kubernetes控制管理服务器"></a>Kubernetes控制管理服务器</h3><p>所有其它的集群级别的功能目前都是由控制管理器所负责。例如，端点对象是被端点控制器来创建和更新。这些最终可以被分隔成不同的部件来让它们独自的可插拔。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/user-guide/replication-controller.md">replicationcont</a><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/user-guide/replication-controller.md">roller</a>（PS:官方 英文）是一种建立于简单的 <a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/kubernetes-pod">pod</a> API之上的一种机制。一旦实现，我们最终计划把这变成一种通用的插件机制。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/architecture.md">https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/architecture.md</a></p>
<p><a target="_blank" rel="noopener" href="https://feisky.gitbooks.io/kubernetes/architecture/architecture.html">https://feisky.gitbooks.io/kubernetes/architecture/architecture.html</a></p>
<h2 id="kubernetes设计理念"><a href="#kubernetes设计理念" class="headerlink" title="kubernetes设计理念"></a>kubernetes设计理念</h2><h3 id="Kubernetes的核心技术概念和API对象"><a href="#Kubernetes的核心技术概念和API对象" class="headerlink" title="Kubernetes的核心技术概念和API对象"></a>Kubernetes的核心技术概念和API对象</h3><p><strong>API对象是K8s集群中的管理操作单元。</strong>K8s集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。</p>
<p>每个API对象都有3大类属性：<strong>元数据metadata</strong>、<strong>规范spec</strong>和<strong>状态status</strong>。<strong>元数据是用来标识API对象的</strong>，每个对象都至少有3个元数据：namespace，name和uid；除此以外还有各种各样的标签labels用来标识和匹配不同的对象，例如用户可以用标签env来标识区分不同的服务部署环境，分别用env=dev、env=testing、env=production来标识开发、测试、生产的不同服务。<strong>规范描述了用户期望K8s集群中的分布式系统达到的理想状态（Desired State）</strong>，例如用户可以通过复制控制器Replication Controller设置期望的Pod副本数为3；<strong>status描述了系统实际当前达到的状态（Status）</strong>，例如系统当前实际的Pod副本数为2；那么复制控制器当前的程序逻辑就是自动启动新的Pod，争取达到副本数为3。</p>
<p><strong>K8s中所有的配置都是通过API对象的spec去设置的，也就是用户通过配置系统的理想状态来改变系统，这是k8s重要设计理念之一</strong>，即<strong>所有的操作都是声明式（Declarative）的而不是命令式（Imperative）的</strong>。声明式操作在分布式系统中的好处是稳定，不怕丢操作或运行多次，例如设置副本数为3的操作运行多次也还是一个结果，而给副本数加1的操作就不是声明式的，运行多次结果就错了。</p>
<h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>K8s有很多技术概念，同时对应很多API对象，最重要的也是最基础的是微服务Pod。<strong>Pod是在K8s集群中运行部署应用或服务的最小单元</strong>，它是可以支持多容器的。Pod的设计理念是<strong>支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务</strong>。Pod对多容器的支持是K8s最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p>
<p>Pod是K8s集群中所有业务类型的基础，可以看作运行在K8s集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8s中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为Deployment、Job、DaemonSet和PetSet，本文后面会一一介绍。</p>
<h4 id="复制控制器（Replication-Controller，RC）"><a href="#复制控制器（Replication-Controller，RC）" class="headerlink" title="复制控制器（Replication Controller，RC）"></a>复制控制器（Replication Controller，RC）</h4><p><strong>RC是K8s集群中最早的保证Pod高可用的API对象</strong> 。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。<strong>即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力</strong>，保证永远有1个Pod在运行。RC是K8s较早期的技术概念，<strong>只适用于长期伺服型的业务类型</strong>，比如控制小机器人提供高可用的Web服务。</p>
<h4 id="副本集（Replica-Set，RS）"><a href="#副本集（Replica-Set，RS）" class="headerlink" title="副本集（Replica Set，RS）"></a>副本集（Replica Set，RS）</h4><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能<strong>支持更多种类的匹配模式</strong>。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p>
<h4 id="部署-Deployment"><a href="#部署-Deployment" class="headerlink" title="部署(Deployment)"></a>部署(Deployment)</h4><p><strong>部署表示用户对K8s集群的一次更新操作。</strong>部署是一个比RS应用模式更广的API对象，<strong>可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务</strong>。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的Deployment来描述。以K8s的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p>
<h4 id="服务（Service）"><a href="#服务（Service）" class="headerlink" title="服务（Service）"></a>服务（Service）</h4><p><strong>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。</strong>一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。<strong>要稳定地提供服务需要服务发现和负载均衡能力。</strong>服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在K8s集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在K8s集群中微服务的<strong>负载均衡是由Kube-proxy实现的</strong>。Kube-proxy是K8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8s的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解决反向代理的负载均衡和高可用问题。</p>
<h4 id="任务（Job）"><a href="#任务（Job）" class="headerlink" title="任务（Job）"></a>任务（Job）</h4><p><strong>Job是K8s用来控制批处理型任务的API对象。</strong>批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。<strong>Job管理的Pod根据用户的设置把任务成功完成就自动退出了</strong>。成功完成的标志根据不同的<code>spec.completions</code>策略而不同：单Pod型任务有一个Pod成功就标志完成；定数成功型任务保证有N个任务全部成功；工作队列型任务根据应用确认的全局成功而标志成功。</p>
<h4 id="后台支撑服务集（DaemonSet）"><a href="#后台支撑服务集（DaemonSet）" class="headerlink" title="后台支撑服务集（DaemonSet）"></a>后台支撑服务集（DaemonSet）</h4><p>长期伺服型和批处理型服务的核心在业务应用，<strong>可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行</strong>；而<strong>后台支撑型服务的核心关注点在K8s集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行</strong>。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。<strong>典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持K8s集群运行的服务。</strong></p>
<h4 id="有状态服务集（PetSet）"><a href="#有状态服务集（PetSet）" class="headerlink" title="有状态服务集（PetSet）"></a>有状态服务集（PetSet）</h4><p>K8s在1.3版本里发布了Alpha版的PetSet功能。在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）。<strong>RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了、名字和启动在哪儿都不重要，重要的只是Pod总数</strong>；而<strong>PetSet是用来控制有状态服务，PetSet中的每个Pod的名字都是事先确定的，不能更改</strong>。<strong>PetSet中Pod的名字的作用，并不是《千与千寻》的人性原因，而是关联与该Pod对应的状态。</strong></p>
<p><strong>对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别</strong>*（这似乎也确实意味着失去了人性特征）；<strong>对于PetSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务</strong>。</p>
<p>适合于PetSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务。PetSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用PetSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，PetSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。PetSet还只在Alpha阶段，后面的设计如何演变，我们还要继续观察。</p>
<h4 id="集群联邦（Federation）"><a href="#集群联邦（Federation）" class="headerlink" title="集群联邦（Federation）"></a>集群联邦（Federation）</h4><p>K8s在1.3版本里发布了beta版的Federation功能。在云计算环境中，服务的作用距离范围从近到远一般可以有：同主机（Host，Node）、跨主机同可用区（Available Zone）、跨可用区同地区（Region）、跨地区同服务商（Cloud Service Provider）、跨云平台。<strong>K8s的设计定位是单一集群在同一个地域内，因为同一个地区的网络性能才能满足K8s的调度和计算存储连接要求。</strong>而联合集群服务就是为提供跨Region跨服务商K8s集群服务而设计的。</p>
<p>每个K8s Federation有自己的分布式存储、API Server和Controller Manager。用户可以通过Federation的API Server注册该Federation的成员K8s Cluster。当用户通过Federation的API Server创建、更改API对象时，Federation API Server会在自己所有注册的子K8s Cluster都创建一份对应的API对象。在提供业务请求服务时，K8s Federation会先在自己的各个子Cluster之间做负载均衡，而对于发送到某个具体K8s Cluster的业务请求，会依照这个K8s Cluster独立提供服务时一样的调度模式去做K8s Cluster内部的负载均衡。而Cluster之间的负载均衡是通过域名服务的负载均衡来实现的。</p>
<p>所有的设计都尽量不影响K8s Cluster现有的工作机制，这样对于每个子K8s集群来说，并不需要更外层的有一个K8s Federation，也就是意味着所有现有的K8s代码和机制不需要因为Federation功能有任何变化。</p>
<h4 id="存储卷（Volume）"><a href="#存储卷（Volume）" class="headerlink" title="存储卷（Volume）"></a>存储卷（Volume）</h4><p>K8s集群中的存储卷跟Docker的存储卷有些类似，只不过Docker的存储卷作用范围为一个容器，而<strong>K8s的存储卷的生命周期和作用范围是一个Pod</strong>。每个Pod中声明的存储卷由Pod中的所有容器共享。K8s支持非常多的存储卷类型，特别的，支持多种公有云平台的存储，包括AWS，Google和Azure云；支持多种分布式存储包括GlusterFS和Ceph；也支持较容易使用的主机本地目录hostPath和NFS。K8s还支持使用Persistent Volume Claim即PVC这种逻辑存储，使用这种存储，使得存储的使用者可以忽略后台的实际存储技术（例如AWS，Google或GlusterFS和Ceph），而将有关存储实际技术的配置交给存储管理员通过Persistent Volume来配置。</p>
<h4 id="持久存储卷（Persistent-Volume，PV）和持久存储卷声明（Persistent-Volume-Claim，PVC）"><a href="#持久存储卷（Persistent-Volume，PV）和持久存储卷声明（Persistent-Volume-Claim，PVC）" class="headerlink" title="持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）"></a>持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）</h4><p><strong>PV和PVC使得K8s集群具备了存储的逻辑抽象能力</strong>，使得在配置Pod的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给PV的配置者，即集群的管理者。存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有K8s集群的使用者即服务的管理员来配置。</p>
<h4 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h4><p><strong>K8s集群中的计算能力由Node提供</strong>，最初Node称为服务节点Minion，后来改名为Node。K8s集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p>
<h4 id="密钥对象（Secret）"><a href="#密钥对象（Secret）" class="headerlink" title="密钥对象（Secret）"></a>密钥对象（Secret）</h4><p><strong>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。</strong>使用Secret的好处是可以避免把敏感信息明文写在配置文件里。在K8s集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问AWS存储的用户名密码。为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个Secret对象，而在配置文件中通过Secret对象引用这些敏感信息。这种方式的好处包括：意图明确，避免重复，减少暴漏机会。</p>
<h4 id="用户帐户（User-Account）和服务帐户（Service-Account）"><a href="#用户帐户（User-Account）和服务帐户（Service-Account）" class="headerlink" title="用户帐户（User Account）和服务帐户（Service Account）"></a>用户帐户（User Account）和服务帐户（Service Account）</h4><p>顾名思义，<strong>用户帐户为人提供账户标识，而服务账户为计算机进程和K8s集群中运行的Pod提供账户标识。</strong>用户帐户和服务帐户的一个区别是作用范围；用户帐户对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的；而服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p>
<h4 id="名字空间（Namespace）"><a href="#名字空间（Namespace）" class="headerlink" title="名字空间（Namespace）"></a>名字空间（Namespace）</h4><p><strong>名字空间为K8s集群提供虚拟的隔离作用</strong>，K8s集群初始有两个名字空间，分别是默认名字空间default和系统名字空间kube-system，除此以外，管理员可以可以创建新的名字空间满足需要。</p>
<h4 id="RBAC访问授权"><a href="#RBAC访问授权" class="headerlink" title="RBAC访问授权"></a>RBAC访问授权</h4><p>K8s在1.3版本中发布了alpha版的基于角色的访问控制（Role-based Access Control，RBAC）的授权模式。相对于基于属性的访问控制（Attribute-based Access Control，ABAC），RBAC主要是引入了角色（Role）和角色绑定（RoleBinding）的抽象概念。在ABAC中，K8s集群中的访问策略只能跟用户直接关联；而在RBAC中，访问策略可以跟某个角色关联，具体的用户在跟一个或多个角色相关联。显然，RBAC像其他新功能一样，每次引入新功能，都会引入新的API对象，从而引入新的概念抽象，而这一新的概念抽象一定会使集群服务管理和使用更容易扩展和重用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从K8s的系统架构、技术概念和设计理念，我们可以看到K8s系统最核心的两个设计理念：一个是<strong>容错性</strong>，一个是<strong>易扩展性</strong>。容错性实际是保证K8s系统稳定性和安全性的基础，易扩展性是保证K8s对变更友好，可以快速迭代增加新功能的基础。</p>
</div><div class="tags"><a href="/tags/技术分享"><i class="fa fa-tag">技术分享</i></a><a href="/tags/Kubernetes"><i class="fa fa-tag">Kubernetes</i></a></div><div class="post-nav"><a class="pre" href="/2019/07/16/Kubernetes-install/">Kubernetes安装部署</a><a class="next" href="/2019/06/01/ApolloBuild/">搭建携程Apollo分布式配置中心</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://giottolee.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">年终总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://github.com/GiottoLee" title="Github" target="_blank">Github</a><ul></ul><a href="https://www.zhihu.com/people/SilverBullet_SDU" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://space.bilibili.com/7877090" title="Bilibili" target="_blank">Bilibili</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">SilverBullet.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>